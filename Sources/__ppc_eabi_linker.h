/***************************************************************************/
/*

FILE
	__ppc_eabi_linker.h

DESCRIPTION

	Linker-generated symbols for sections as defined for use in [EABI95].

-------------------------------------------------------------------------------------------
ELF sect.		mem ini	siz	ROM addr symbol		  	RAM (virtual) addr	RAM (virtual) end
--------------- --- ---	--- ----------------------- -------------------	-------------------
.text			RX	 Y	N/A _f_text_rom				_f_text				_e_text
.data			RW	 Y	any _f_data_rom				_f_data				_e_data
.rodata			R	 Y	any _f_rodata_rom			_f_rodata			_e_rodata
.bss			RW	 0	any 						_f_bss				_e_bss

.sdata			RW	 Y	<=8 _f_sdata_rom			_f_sdata			_e_sdata
.sbss			RW	 0	<=8 						_f_sbss				_e_sbss

.sdata2			RW*  Y	<=8 _f_sdata2_rom			_f_sdata2			_e_sdata2
.sbss2			RW	 0	<=8 						_f_sbss2			_e_sbss2

.PPC.EMB.sdata0 RW	 Y	<=8 _f_PPC_EMB_sdata0_rom	_f_PPC_EMB_sdata0	_e_PPC_EMB_sdata0
.PPC.EMB.sbss0	RW	 0	<=8 N/A						_f_PPC_EMB_sbss0	_e_PPC_EMB_sbss0

(stack)			RW	 N	N/A							_stack_addr			_stack_end
(heap)			RW	 N	N/A							_heap_addr			_heap_end

----------------------------------------------------------------------------------------------
ELF sect.	Name of the ELF section
mem			Memory access: R = R/O, RW = Read/Write, RW* = intended R/O, but RW, RX = Execute
siz			Datum size
ini			Initialized? 0 = filled with zeros, Y = init'ed, N = not init'ed
end			Virtual address following section
----------------------------------------------------------------------------------------------

The symbols above are automatically generated by the linker based on the spelling of the
section name.  Symbols not above, i.e., symbols for user defined sections follow the same
naming convention.

In all cases, any '.' in the name is replaced with a '_'.  Addresses begin with a '_f', address
after last byte in section begin with '_e' and rom addresses end in a '_rom'.  The linker command 
file allows you to define your own symbols and it allows you to create an alias to the 
automatically generated symbols.

For example:
ftext = ADDR(.text); 	// define ftext
etext = _e_text; 		// create an alias

Calculate the size of the section by subtracting the begin RAM address from the end RAM
address.

REFERENCES

	[EABI95]	PowerPC Embedded Application Binary Interface,
				32-bit Implementation.	Version 1.0, Initial Release,
				1/10/95.  Stephen Sobek, Motorola, and Kevin Burke, IBM.

NOTES

COPYRIGHT	

CodeWarrior PowerPC EABI Runtime Support Library 
Copyright © 1995-2006 Freescale Semiconductor, Inc.  All rights reserved.

$Date: 2009/05/14 20:36:02 $
$Revision: 1.1 $


HISTORY
	97 APR 16 LLY	Moved from __start.c, new names for 4/1/97 PPC EABI tools.
	97 JUN 8 MEA	New names for 6/8/97 PPC EABI tools (C++ exceptions).
	97 SEP 11 MEA	_heap_size and _stack_size are now in bytes.
	97 DEC  7 MEA	linker generated symbols are now forced into the .init section.
					Created new symbols _bss_init_info and _rom_copy_info.
	98 JAN 14 MEA	New spelling for symbols.
	98 JAN 20 MEA	Removed size symbols and added end symbols to make them
					easier to access from C.


*/
/***************************************************************************/

#pragma once

/*
 *	Stack and heap pointers and size
 */

__declspec(section ".init") extern char		 	_stack_addr[];	/* starting address for stack */
__declspec(section ".init") extern char 		_stack_end[];	/* address after end byte of stack */
__declspec(section ".init") extern char		 	_heap_addr[];	/* starting address for heap */
__declspec(section ".init") extern char 		_heap_end[];	/* address after end byte of heap */

/*
 *	extabindex -- read only C++ Exception Tables
 */
 
__declspec(section ".init") extern const char 	_fextabindex_rom[];	/* extabindex source (ROM) address at beginning */
__declspec(section ".init") extern char 		_fextabindex[];		/* extabindex dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_eextabindex[];		/* extabindex dest. (RAM) address after end byte */

/*
 *	Small Data pointers (PPC EABI)
 */

__declspec(section ".init") extern char			_SDA_BASE_[];	/* Small Data Area (<=8 bytes) base addr */
																/* used for .sdata, .sbss */
__declspec(section ".init") extern char			_SDA2_BASE_[];	/* Small Data Area 2 (<=8 bytes), base addr */
																/* used for .sdata2, .sbss2 */
/*
 *	Special symbol for copying sections from rom to ram: _rom_copy_info
 *	if size field is zero, there are no more valid sections
 *	see __init_data for example.  _rom_copy_info is a true C variable.
 *
 *	this version is used except when the abi is sda pic/pid
 */

typedef struct __rom_copy_info {
	char * 			rom;		/* address in rom */
	char * 			addr;		/* address in ram (executing address) */
	unsigned int	size;		/* size of section */
} __rom_copy_info;

__declspec(section ".init") extern __rom_copy_info 	_rom_copy_info[];	/* An array of all initialized (data, text or mixed) sections */

/*
 *	Special symbol for copying sections from rom to ram: _pic_rom_copy_info.
 *	If ram_addr and ram_end field is zero, there are no more valid sections
 *	See __init_data for example.  _pic_rom_copy_info is a true C variable.
 *	For sda pic pid.  If ram_end and ram_addr are swapped such that ram_end < ram_addr,
 *	then segment is internal, otherwise it is external.
 */

typedef struct __pic_rom_copy_info {
	unsigned char * 		rom_addr;		/* address in rom */
	unsigned char * 		rom_end;		/* end address in rom;  new for eppc 7.0 */
	unsigned char * 		ram_addr;		/* address in ram (executing address) */
	unsigned char * 		ram_end;		/* end address in ram (executing address);  pre-eppc 7.0, this was the size */
} __pic_rom_copy_info;

__declspec(section ".init") extern __pic_rom_copy_info 	_pic_rom_copy_info[];	/* An array of all initialized (data, text or mixed) sections */

/*
 *	Special symbol for initializing bss type sections: _bss_init_info
 *	if size field is zero, there are no more valid sections
 *	see __init_data for example.  _bss_init_info is a true C variable.
 *
 *	this version is used except when the abi is sda pic/pid
 */

typedef struct __bss_init_info {
	char * 			addr;		/* address in ram (executing address) */
	unsigned int	size;		/* size of section */
} __bss_init_info;

__declspec(section ".init") extern __bss_init_info 	_bss_init_info[];	/* An array of all uninitialized data sections */

/*
 *	Special symbol for copying sections from rom to ram: __pic_bss_init_info.
 *	If ram_addr and ram_end field is zero, there are no more valid sections
 *	See __init_data for example.  __pic_bss_init_info is a true C variable.
 *	For sda pic pid.  If ram_end and ram_addr are swapped such that ram_end < ram_addr,
 *	then segment is internal, otherwise it is external.
 */

typedef struct __pic_bss_init_info {
	unsigned char * 		ram_addr;		/* address in ram (executing address) */
	unsigned char * 		ram_end;		/* end address in ram (executing address);  pre-eppc 7.0, this was the size */
} __pic_bss_init_info;

__declspec(section ".init") extern __pic_bss_init_info 	_pic_bss_init_info[];	/* An array of all uninitialized data sections */

/*
 *	Special symbol for initializing c++ exceptions tables: _eti_init_info
 *	if code_size field is zero, there are no more valid sections
 *	see __init_cpp_exceptions for example.  _eti_init_info is a true C variable.
 *
 *	this version is used except when the abi is sda pic/pid
 */

typedef struct __eti_init_info {
	void * 			eti_start;	/* address of start of exception data for this code segment */
	void *			eti_end;	/* address of end of exception data for this code segment */
	void * 			code_start;	/* address of first function */
	unsigned long	code_size;	/* ((funcN.address - func1.address) + funcN.size) */
} __eti_init_info;

__declspec(section ".init") extern __eti_init_info 	_eti_init_info[];	/* An array of all uninitialized data sections */

/*
 *	Special symbol for initializing c++ exceptions tables: _pic_eti_init_info.
 *	If code_start and code_end field is zero, there are no more valid sections
 *	See __init_cpp_exceptions for example.  _pic_eti_init_info is a true C variable.
 *	For sda pic pid.  If eti_start and eti_end are swapped such that eti_end < eti_start,
 *	then segment is internal, otherwise it is external.  If code_start and code_end are 
 *	swapped such that code_end < code_start, then segment is internal, otherwise it is external.
 */

typedef struct __pic_eti_init_info {
	unsigned char * 		eti_start;	/* address of start of exception data for this code segment */
	unsigned char * 		eti_end;	/* address of end of exception data for this code segment */
	unsigned char * 		code_start;	/* address of first function */
	unsigned char * 		code_end;	/* address of end of this code segment; pre-eppc 7.0, this was the size */
} __pic_eti_init_info;

__declspec(section ".init") extern __pic_eti_init_info 	_pic_eti_init_info[];	/* An array of all uninitialized data sections */

/*	
 *	If you use the CodeWarrior start-up routines in __start.c and __ppc_eabi_init.c,
 *	the above are the only linker generated symbols you will need.  The linker, however
 *	will still automatically generate symbols for each output section in your project.
 *	The following are declarations for the standard sections.
 */

/*
 *	.init -- executable PowerPC EABI code
 */

__declspec(section ".init") extern const char 	_f_init_rom[];		/* .init source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_init[];			/* .init dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_init[];			/* .init dest. (RAM) address after end byte */

/*
 *	.text -- executable PowerPC EABI code
 */

__declspec(section ".init") extern const char 	_f_text_rom[];		/* .text source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_text[];			/* .text dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_text[];			/* .text dest. (RAM) address after end byte */
 
/*
 *	.rodata -- read only data
 */

__declspec(section ".init") extern const char 	_f_rodata_rom[];	/* .rodata source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_rodata[];		/* .rodata dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_rodata[];		/* .rodata dest. (RAM) address after end byte */

/*
 *	extab -- read only C++ Exception Tables
 */
 
__declspec(section ".init") extern const char 	_fextab_rom[];		/* extab source (ROM) address at beginning */
__declspec(section ".init") extern char 		_fextab[];			/* extab dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_eextab[];			/* extab dest. (RAM) address after end byte */

/*
 *	.data -- read/write initialized data
 */

__declspec(section ".init") extern const char 	_f_data_rom[];		/* .data source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_data[];			/* .data dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_data[];			/* .data dest. (RAM) address after end byte */

/*
 *	.bss -- read/write initialized (zeroed) data
 */

__declspec(section ".init") extern char 		_f_bss[];			/* .bss dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_bss[];			/* .bss dest. (RAM) address after end byte */

/*
 *	.sdata -- small data
 */
 
__declspec(section ".init") extern const char 	_f_sdata_rom[];		/* .sdata source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_sdata[];			/* .sdata dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_sdata[];			/* .sdata dest. (RAM) address after end byte */

/*
 *	.sbss -- small initialized (zeroed) data
 */
 
__declspec(section ".init") extern char 		_f_sbss[];			/* .sbss dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_sbss[];			/* .sbss dest. (RAM) address after end byte */

/*
 *	.sdata2 -- PPC embedded small initlialized data
 */

__declspec(section ".init") extern const char 	_f_sdata2_rom[];	/* .sdata2 source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_sdata2[];		/* .sdata2 dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_sdata2[];		/* .sdata2 dest. (RAM) address after end byte */

/*
 *	.sbss2 -- PPC embedded small initialized (zeroed) data
 */
 
__declspec(section ".init") extern char 		_f_sbss2[];			/* .sbss2 dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_sbss2[];			/* .sbss2 dest. (RAM) address after end byte */

/*
 *	.PPC.EMB.sdata0 -- PPC embedded small data centered around addr. zero
 */

__declspec(section ".init") extern const char 	_f_PPC_EMB_sdata0_rom[];	/* .PPC.EMB.sdata0 source (ROM) address at beginning */
__declspec(section ".init") extern char 		_f_PPC_EMB_sdata0[];		/* .PPC.EMB.sdata0 dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_PPC_EMB_sdata0[];		/* .PPC.EMB.sdata0 dest. (RAM) address after end byte */

/*
 *	.PPC.EMB.sbss0 -- PPC embedded small initlialized (zeroed) data
 */

__declspec(section ".init") extern char 		_f_PPC_EMB_sbss0[];	/* .PPC.EMB. dest. (RAM) address at beginning */
__declspec(section ".init") extern char 		_e_PPC_EMB_sbss0[];	/* .PPC.EMB. dest. (RAM) address after end byte */

/*
 *	the following are used by the runtime for EABI PIC/PID 
 */

__declspec(section ".init") extern unsigned int	_f_mwerks_fixup[];			/* .mwerks_fixup dest. (RAM) address at beginning */
__declspec(section ".init") extern unsigned int _e_mwerks_fixup[];			/* .mwerks_fixup dest. (RAM) address after end byte */

__declspec(section ".init") extern char 		_ABS_SDA_BASE_[];	/* same as _SDA_BASE_ but is absolute addressed even with SDA PIC/PID */
__declspec(section ".init") extern char 		_ABS_SDA2_BASE_[];	/* same as _SDA2_BASE_ but is absolute addressed even with SDA PIC/PID */
